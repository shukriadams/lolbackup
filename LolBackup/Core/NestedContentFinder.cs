using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace LolBackup
{
    /// <summary>
    /// Finds files and folders nested within a given folder
    /// </summary>
    public class NestedContentFinder
    {
        #region FIELDS

        private string _path;

        private string[] _ignoreFileTypes;

        private string[] _ignoreFolders;

        private WriteMessageDelegate _writeMessageDelegate;

        #endregion

        #region PROPERTIES

        /// <summary>
        /// If not external message receiver is defined, messages will be placed in this collection.
        /// </summary>
        readonly IList<string> _messages = new List<string>();

        /// <summary>
        /// List of all message generated by backup process. This is primarily for testing purposes.
        /// </summary>
        public IList<string> Messages
        {
            get
            {
                return _messages;
            }
        }

        #endregion

        #region CTORS

        /// <summary>
        /// 
        /// </summary>
        /// <param name="path"></param>
        /// <param name="ignoreFileTypes"></param>
        /// <param name="ignorefolders"></param>
        public NestedContentFinder(
            string path,
            string[] ignoreFileTypes,
            string[] ignorefolders,
            WriteMessageDelegate writeMessageDelegate
            )
        {
            _path = path;
            _ignoreFileTypes = ignoreFileTypes;
            _ignoreFolders = ignorefolders;

            if (writeMessageDelegate == null)
                _writeMessageDelegate = WriteSelf;
            else
                _writeMessageDelegate = writeMessageDelegate;
        }

        #endregion

        #region METHODS

        /// <summary>
        /// 
        /// </summary>
        /// <param name="path"></param>
        /// <param name="fileTypes"></param>
        /// <param name="ignorefolders"></param>
        /// <returns></returns>
        public string[] Process(

            )
        {
            if (_ignoreFolders != null)
                for (int i = 0; i < _ignoreFolders.Length; i++)
                    _ignoreFolders[i] = _ignoreFolders[i].ToLower();

            List<string> filesOut = new List<string>();
            List<string> files = new List<string>();
            this.GetFilesUnderInternal(_path, filesOut);
            return filesOut.ToArray();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="path">Path to search in</param>
        /// <param name="files">Holder of files to return</param>
        private void GetFilesUnderInternal(
            string path,
            ICollection<string> files
            )
        {
            try
            {

                // handles files
                if (!Directory.Exists(path))
                    return;

                _writeMessageDelegate.Invoke(string.Format("Scanning {0}", path));

                DirectoryInfo dir = new DirectoryInfo(path);
                FileInfo[] filesInDir = null;

                if (_ignoreFileTypes == null)
                    filesInDir = dir.GetFiles();
                else
                {
                    string search = "";

                    foreach (string fileType in _ignoreFileTypes)
                        search += "*." + fileType;

                    filesInDir = dir.GetFiles(search);
                }

                foreach (FileInfo file in filesInDir)
                {
                    try
                    {
                        files.Add(file.FullName);
                    }
                    catch (PathTooLongException)
                    {
                        // suppress these
                    }
                }


                // handles folders
                DirectoryInfo[] dirs = dir.GetDirectories();

                foreach (DirectoryInfo child in dirs)
                    if (_ignoreFolders == null || (!_ignoreFolders.Contains(child.FullName.ToLower()) && !_ignoreFolders.Contains(child.Name)))
                        GetFilesUnderInternal(
                            child.FullName,
                            files);
            }
            catch (UnauthorizedAccessException)
            {
                // suppress these exceptions
            }
            catch (PathTooLongException)
            {
                // suppress these, they will be hit a lot
            }
        }

        /// <summary>
        /// Fall back for creating a backup process without an external message receiver.
        /// </summary>
        /// <param name="message"></param>
        private void WriteSelf(string message)
        {
            _messages.Add(message);
        }

        #endregion
    }
}
